火曜日の Common Lisp に関するタスクである簡単な数学問題を解く関数の作成について、詳細を補完し、具体的な計画を立てます。

### タスクの概要

Common Lisp を使用して、数学的な問題を解くための関数を一つまたは複数作成します。
このタスクでは、限られた時間（30 分）の中で、フィボナッチ数列の計算や素数判定といった、比較的単純なアルゴリズムの実装に挑戦します。

### タスクの目標

- Common Lisp の基本的な構文と関数の使用方法を理解・適用する。
- 選択した数学的問題のアルゴリズムを理解し、Lisp での実装方法を考える。
- 実装した関数のテストを行い、正確に動作することを確認する。

### 具体的なステップ

#### ステップ 1: 問題の選定

- **フィボナッチ数列の計算:** 与えられたインデックスに対するフィボナッチ数を返す関数を作成します。
- **素数判定:** 与えられた数が素数であるかどうかを判定する関数を作成します。

#### ステップ 2: アルゴリズムの理解

- 選んだ問題（フィボナッチ数列または素数判定）について、必要なアルゴリズムを理解します。
- フィボナッチ数列の場合、再帰的または反復的なアプローチを考慮します。
- 素数判定の場合、効率的な判定方法を検討します（例: 2 から √n までの数で割り切れないかチェック）。

#### ステップ 3: 関数の実装

- Common Lisp を使用して、選定したアルゴリズムを実装します。
- Lisp の関数定義（`defun`）を使用して、問題を解くための関数を作成します。

#### ステップ 4: テストとデバッグ

- 実装した関数に対して、いくつかのテストケースを実行して、正確に動作することを確認します。
- 必要に応じてデバッグを行い、エラーや問題点を修正します。

### 実装例

#### フィボナッチ数列の計算（再帰的アプローチ）

```lisp
(defun fibonacci (n)
  (if (or (= n 0) (= n 1))
      n
      (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))
```

#### 素数判定

```lisp
(defun is-prime (n)
  (if (< n 2)
      nil
      (loop for i from 2 to (isqrt n) never (zerop (mod n i)))))
```

### 注意点

- 再帰的なアプローチを使用する場合は、スタックオーバーフローに注意し、必要に応じて末尾再帰最適化を検討します。
- 実装後のテストでは、特殊なケース（例: フィボナッチ数列での 0 や 1、素数判定での 1 や 2）も考慮に入れます。

この計画に従って、火曜日の 30 分間で Lisp による数学問題の解決に挑戦し、Common Lisp のスキルを向上させることができます。
